<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>YARRRML</title>
    <script 
     src='./respec-w3c-common.js'
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        editors: [{
          name: "Ben De Meester",
          url: "https://ben.de-meester.org",
          mailto: "ben.demeester@ugent.be",
          company: 'imec — Ghent University — IDLab',
        },{
          name: "Pieter Heyvaert",
          url: "https://pieterheyvaert.com",
          mailto: "pheyvaer.heyvaert@ugent.be",
          company: 'imec — Ghent University — IDLab',
        }],
        processVersion: 2017,
        // edDraftURI: "http://some.github.repo",
        shortName: "yarrrml"
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        YARRRML is a human readable text-based representation for declarative generation rules.
        It is a subset of [[YAML]],
        a widely used data serialization language designed to be human-friendly.
      </p>
    </section>
    <section id='sotd'>
    </section>
<!--<section>-->
    <!--<h2>Introduction</h2>-->

    <!--<section>-->
        <!--<h2>Goals</h2>-->

    <!--</section>-->

    <!--<section>-->
        <!--<h2>Relation to existing mapping languages</h2>-->

    <!--</section>-->

    <!--<section>-->
        <!--<h2>Relation to YAML</h2>-->

        <!--<p>-->
            <!--YARRRML is a subset of the YAML.-->
        <!--</p>-->
    <!--</section>-->
<!--</section>-->

    <section>
      <h2>Terminology</h2>

      <dl>
        <dt><dfn>subject</dfn></dt>
        <dd>the subject of an RDF triple</dd>

        <dt><dfn>predicate</dfn></dt>
        <dd>the predicate of an RDF triple</dd>

        <dt><dfn>object</dfn></dt>
        <dd>the object of an RDF triple</dd>

        <dt><dfn>class</dfn></dt>
        <dd>the type of an entity</dd>

        <dt><dfn>datatype</dfn></dt>
        <dd>the type of a literal value</dd>

        <dt><dfn>reference</dfn></dt>
        <dd></dd>

        <dt><dfn>function</dfn></dt>
        <dd>a programmatic function that takes 0 or more input parameters and returns a single result</dd>
      </dl>
    </section>

    <section>
      <h2>Profiles</h2>

      <p>
        This specification includes the following main profiles for tools that process YARRRML documents:
      </p>

      <ul>
        <li>R2RML: applies the semantics specified by [[R2RML]]; and</li>
        <li>RML: applies the semantics specified by RML.</li>
      </ul>

      <p>
        These profiles can be extended with additional profiles, which cannot be used on their own:
      </p>

      <ul>
        <li>FnO: applies the semantics specified by FnO;</li>
        <li>DCAT: applies the semantics specified by DCAT;</li>
        <li>D2RQ: applies the semantics specified by D2RQ;</li>
        <li>SD: applies the semantics specified by SD; and</li>
        <li>CSVW: applies the semantics specified by CSVW ([[csv2rdf]]).</li>
      </ul>
    </section>

    <section>
      <h2>Base IRI</h2>

      <p>
        A base IRI can be defined.
        This IRI will be used for the creation of the IRIs of the term maps and sources of the [R2]RML rules.
      </p>
      <p>
        A base IRI can be added by adding key <code>base</code> with as value the IRI itself to the root of the document.
        In the following example the base IRI is set to <code>http://mybaseiri.com#</code>.
      </p>

      <pre id="example-base-iri" class="nohighlight example" title="base IRI">
        base: http://mybaseiri.com#
      </pre>
    </section>

    <section>
      <h2>Prefixes and namespaces</h2>

      <p>
        A set of prefixes and namespaces are predefined by default in every YARRRML document.
        There are the same as the predefined prefixes for <a href="https://www.w3.org/2011/rdfa-context/rdfa-1.1">RDFa</a>.
      </p>

      <p>
        Custom prefixes can be added by adding the collection <code>prefixes</code> to the root of the document.
        Each combination of a prefix and namespace is added to this collection as a key-value pair.

        In the following example two prefixes are defined: <code>ex</code> and <code>test</code>.
      </p>

      <pre id="example-custom-prefixes" class="nohighlight example" title="custom prefixes">
        prefixes:
          ex: http://www.example.com
          test: http://www.test.com
      </pre>
    </section>

    <section>
      <h2>Template</h2>

      <p>
        A template contains 0 or more constant strings and 0 or more references to data in a data.
        References are prefixed with <code>$(</code> and suffixed with <code>)</code>.
        For example, <code>foo</code> is a template with one constant string.
        <code>$(id)</code> is a template with one reference to <code>id</code>.
        <code>foo-$(id)</code> is a template with one constant string <code>foo-</code> and one reference to <code>id</code>.
      </p>
    </section>

    <section>
      <h2>Data sources</h2>

      <p>
        The data sources are can be defined in the <code>sources</code> collection in the root of the document.
        Each source is added to this collection via a key-value pair.
        The key has to be unique for every source.
        The value is a collection with three keys
        <code>access</code> (required), <code>referenceFormulation</code> (required), and <code>iterator</code> (conditionally required).
      </p>

        <section>
          <h2>Keys</h2>
          <dl>
            <dt><dfn>access</dfn></dt>
            <dd>the local or remote location of the data source</dd>

            <dt><dfn>driver</dfn> (required profiles: RML, D2RQ)</dt>
            <dd>the local or remote location of the data source</dd>

            <dt><dfn>referenceFormulation</dfn> (required profiles: RML)</dt>
            <dd>the reference formulation used on to access data source</dd>

            <dt><dfn>iterator</dfn> (required profiles: RML)</dt>
            <dd>the path to the different records over which to iterate</dd>

            <dt><dfn>delimiter</dfn> (required profiles: RML, CSVW)</dt>
            <dd>the delimiter to separate fields in a record</dd>

            <dt><dfn>encoding</dfn> (required profiles: RML, CSVW)</dt>
            <dd>the encoding used for the data</dd>

            <dt><dfn>query</dfn> (required profiles: RML, R2RML)</dt>
            <dd>the query to execute on the data source to select only a part of the data</dd>

            <dt><dfn>queryFormulation</dfn> (required profiles: RML, R2RML)</dt>
            <dd>the query formulation used on to query the data source</dd>

            <dt><dfn>credentials</dfn> (required profiles: RML, D2RQ)</dt>
            <dd>the credentials required to access the data source</dd>

            <dt><dfn>username</dfn> (required profiles: RML, D2RQ)</dt>
            <dd>the username required to access the data source</dd>

            <dt><dfn>password</dfn> (required profiles: RML, D2RQ)</dt>
            <dd>the password required to access the data source</dd>
          </dl>
		  
		  <div class="note">
			<p>
				To be precise, the <a>iterator</a> contains a "query" as a string,
				as per specification of the <a>referenceFormulation</a>.
				E.g., when using <a>referenceFormulation</a> <code>xpath</code>,
				the <a>iterator</a> will be interpreted as an xPath statement.
				When using <a>referenceFormulation</a> <code>sparql</code>,
				the <a>iterator</a> will be interpreted as a SPARQL query.
				This is similar for <a>queryFormulation</a> and <a>query</a>.
				The latter however is executed when retrieving the data,
				a so-called "view" of the data.
				The former is executed on top of this view.
			</p>
		  </div>
        </section>

        <section>
          <h2>Reference formulations</h2>
          The following reference formulations are supported for these data formats.

          <dl>
            <dt><dfn>CSV</dfn> (required profiles: RML)</dt>
            <dd>
              The reference formulation <code>csv</code> is used for data sources in the CSV format.
              No iterator is required.
              Every row of a CSV data source is considered as a record.
            </dd>

            <dt><dfn>JSON</dfn> (required profiles: RML)</dt>
            <dd>
              The reference formulation <code>jsonpath</code> is used for data sources that can be access via JSONPath expressions.
              An iterator is required.
            </dd>

            <dt><dfn>XML</dfn> (required profiles: RML)</dt>
            <dd>
              The reference formulation <code>xpath</code> is used for data sources that can be access via XPath expressions.
              An iterator is required.
              The reference formulation <code>xquery</code> is used for data sources that can be access via XQuery queries.
              No iterator is required.
              Every row of the result of the query is considered as a record.
            </dd>
          </dl>
        </section>

      <section>
        <h2>Query formulations</h2>
        The following query formulation are supported for these query languages.

        <dl>
          <dt><dfn>SQL</dfn></dt>
          <dd>
            The following query formulations can be used for data sources that can be queried via a SQL query:

            <ul>
              <li>sql2008</li>
              <li>oracle</li>
              <li>mysql</li>
              <li>mssql</li>
              <li>hsql</li>
              <li>postgresql</li>
              <li>db2</li>
              <li>informix</li>
              <li>ingres</li>
              <li>progress</li>
              <li>sybasease</li>
              <li>sybasesqlanywhere</li>
              <li>virtuoso</li>
              <li>firebird</li>
            </ul>

            This list is based on version IRIs identified by <a href="https://www.w3.org/2001/sw/wiki/RDB2RDF/SQL_Version_IRIs">RDB2RDF</a>.
          </dd>

          <dt><dfn>SPARQL</dfn> (required profiles: RML, SD)</dt>
          <dd>
            The query formulation <code>sparql11</code> is used for data sources that can be queried via a SPARQL 1.1 query.
          </dd>
        </dl>
      </section>

        <section>
          <h2>Examples</h2>
          <p>
            In the following example a single data source is defined <code>person-source</code>.
          </p>

            <pre id="example-ds1" class="example" title="one data source">
              sources:
                person-source:
                  access: data/person.json
                  referenceFormulation: jsonpath
                  iterator: $
            </pre>

          <p>
            A shortcut version of this example looks as follows.
          </p>

            <pre id="example-ds1-sc" class="example" title="one data source using shortcuts">
              sources:
                person-source: [data/person.json~jsonpath, $]
            </pre>

          <p>
            The collection is replaced with an array where
            the first element contains the value for <code>access</code> appended with the <code>~</code> and the value for <code>referenceFormulation</code>, and
            the second element contains the iterator.

          </p>

          <p>
          The following mapping access a SQL database and select the required data via a query.
          </p>

          <pre id="example-db" class="example" title="mapping with database as source">
            mapping:
              person:
                sources:
                  access: http://localhost/example
                  driver: mysql
                  credentials:
                    username: root
                    password: root
                  queryFormulation: sql2008
                  query: |
                    SELECT DEPTNO, DNAME, LOC,
                    (SELECT COUNT(*) FROM EMP WHERE EMP.DEPTNO=DEPT.DEPTNO) AS STAFF
                    FROM DEPT;
                  referenceFormulation: csv
          </pre>
        </section>
    </section>

    <section>
      <h2>Mappings</h2>

        <p>
          The <code>mappings</code> collection contains all the mappings of the document.
          Each mapping is added to this collection via key-value pair.
          The key is unique for each mapping.
          The value is collection containing rules to generate the subjects, predicates, and objects.

          In the following example two mappings are defined: <code>person</code> and <code>project</code>.
        </p>

          <pre id="example-mappings" class="example" title="two mappings">
            mappings:
              person: ...
                project: ...
          </pre>

      <section>
        <h2>Data sources</h2>

        <p>
          Besides defining data sources at the root of the document,
          data sources can also be defined inside a mapping via the collection <code>sources</code>.
          However, no unique key is specified for a source, and, thus, it cannot be referred to from other mappings.
          The key-value to add to a source are the same when defining sources at the root of the document.

          In the following example the mapping <code>person</code> has one source.
        </p>

          <pre id="example-ds" class="example" title="mapping with one data source">
            mapping:
              person:
                sources:
                  access: data/person.json
                  referenceFormulation: jsonpath
                  iterator: $
          </pre>

          A shortcut version of this example looks as follows.

          <pre id="example-ds-sc" class="example" title="mapping with one data source using shortcuts">
            mapping:
              person:
                sources: [data/person.json~jsonpath, $]
          </pre>

          In case a mapping needs to be applied to multiple data sources, multiple sources can be added to the <code>scources</code> collection.
          In the following example the <code>person</code> mapping has two data sources.

          <pre id="example-ds2" class="nohighlight example" title="mapping with two data sources">
            mapping:
              person:
                sources:
                  - access: data/person.json
                    referenceFormulation: jsonpath
                    iterator: $
                  - access: data/person2.json
                    referenceFormulation: jsonpath
                    iterator: "$.persons[*]"
          </pre>

          A shortcut version of this example looks as follows.

          <pre id="example-ds2-sc" class="nohighlight example" title="mapping with two data sources using shortcuts">
            mapping:
              person:
                sources:
                  - [data/person.json~jsonpath, $]
                  - [data/person2.json~jsonpath, "$.persons[*]"]
          </pre>

          If you describe a data source outside of the mappings, you can include via their unique key.

          <pre id="example-ds3" class="nohighlight example" title="mapping with one data sources">
            sources:
              person-source:
                access: data/person.json
                referenceFormulation: jsonpath
                iterator: $

            mapping:
              person:
                sources: person-source
          </pre>

          Multiple sources can be used by using an array of source keys as value for the key <code>sources</code>.

          <pre id="example-ds4" class="example" title="mapping with two data sources">
            sources:
              person-source:
                access: data/person.json
                referenceFormulation: jsonpath
                iterator: $
              person-source2:
                access: data/person2.json
                referenceFormulation: jsonpath
                iterator: "$.person[*]"

            mapping:
              person:
                sources:
                  - [person-source, person-source2]
          </pre>

          A combination of both sources defined outside and inside a mapping is possible.

          <pre id="example-ds5" class="example" title="mapping with two data sources">
            sources:
              person-source:
                access: data/person.json
                referenceFormulation: jsonpath
                iterator: $

            mapping:
              person:
                sources:
                 - person-source
                 - access: data/person2.json
                   referenceFormulation: jsonpath
                   iterator: "$.persons[*]"
          </pre>
      </section>

      <section>
        <h2>Subjects</h2>

        <p>
          For every triple is required to define whether a IRI or blank node needs to used.
          This information is added to a mapping via the collection <code>subjects</code>.
          In the case of an IRI , this collection contains 0 or more templates that specify the IRI.
          In the case of a blank node, this collection is set to <code>null</code> or is not specified at all.

          In the following example the mapping <code>person</code> generate IRI for the subjects based on the template <code>http://wwww.example.com/person/$(id)</code>.
        </p>

          <pre id="example-subject" class="nohighlight example" title="mapping with one subject">
            mappings:
              person:
                subjects: http://wwww.example.com/person/$(id)
          </pre>

          It is also possible to specify multiple subjects.
          In this case an array of templates is used.
          In the following example the mapping <code>person</code> generate subjects based on the templates <code>http://wwww.example.com/person/$(id)</code>
          and <code>http://www.test.com/$(firstname)</code>.

          <pre id="example-subject2" class="example" title="mapping with two subjects">
              mappings:
                person:
                  subjects: [http://wwww.example.com/person/$(id), http://www.test.com/$(firstname)]
          </pre>

          It is possible to apply functions on subjects.
      </section>

      <section>
        <h2>Predicates and objects</h2>

        In the following example the mapping <code>person</code> generates combinations of predicates and objects,
        where the predicate is <code>foaf:firstName</code> and the object is the <code>firstname</code> of each person.

        <pre id="example-po" class="example" title="mapping with one predicate and object">
          mappings:
            person:
              predicateobjects:
                - predicates: foaf:firstName
                  objects: $(firstname)
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-po-sc" class="example" title="mapping with one predicate and object using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [foaf:firstName, $(firstname)]
        </pre>

        It is possible to speficiy multiple predicates and objects.
        In this case an array of templates is used.

        <pre id="example-po2" class="example" title="mapping with two predicates and objects">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects: [$(firstname), $(lastname)]
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-po2-sc" class="example" title="mapping with two predicates and objects using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [[foaf:name, rdfs:label], [$(firstname), $(lastname)]]
        </pre>

        <pre id="example-po3" class="example" title="mapping with object that generates an IRI">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects:
                    value: $(colleague)
                    type: iri
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-po3-sc" class="example" title="mapping with object that generates an IRI using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [[foaf:name, rdfs:label], $(colleague)~iri]
        </pre>

        The inverse predicate can also be added.
        This is only valid when the object is an IRI or a blank node.

        <pre id="example-po-inverse" class="example" title="mapping with one inverse predicate">
          mappings:
            work:
              predicateobjects:
                - predicates: ex:createdBy
                  inversepredicates: ex:created
                  objects: $(foafprofile)
                  type: iri
        </pre>
      </section>

      <section>
        <h2>Datatypes</h2>

        <pre id="example-datatype" class="example" title="mapping with one datatype">
          mappings:
            person:
              predicateobjects:
                - predicates: foaf:firstName
                  objects:
                    value: $(firstname)
                    datatype: xsd:string
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-datatype-sc" class="example" title="mapping with one datatype using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [foaf:firstName, $(firstname), xsd:string]
        </pre>

        <pre id="example-datatype2" class="example" title="mapping with two datatypes">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects:
                    - value: $(firstname)
                      datatype: ex:string
                    - value: $(lastname)
                      datatype: ex:anotherString
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-datatype2-sc" class="example" title="mapping with two datatypes using shortcuts">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects: [[$(firstname), ex:string], [$(lastname), ex:anotherString]]
        </pre>
      </section>

      <section>
        <h2>Languages</h2>

        <pre id="example-lang" class="example" title="mapping with one language">
          mappings:
            person:
              predicateobjects:
                - predicates: foaf:firstName
                  objects:
                    value: $(firstname)
                    language: en
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-lang-sc" class="example" title="mapping with one language using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [foaf:firstName, $(firstname), en~lang]
        </pre>

        <pre id="example-lang2" class="example" title="mapping with two languages">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects:
                    - value: $(firstname)
                      language: en
                    - value: $(lastname)
                      language: nl
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-lang2-sc" class="example" title="mapping with two languages using shortcuts">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects: [[$(firstname), en~lang], [$(lastname), nl~lang]]
        </pre>
      </section>

      <section>
        <h2>Referring to other mappings</h2>

        <p>
          In certain use cases triples need to be generated between the records of two mappings.
          For example, in the following example we have two mappings: persons and projects.
          In the existing data there is for every person a field <code>projectID</code> referring to the project
          on which the person is working.
          Therefore, we want to generate triples between every person and his/her project.
          The <code>objects</code> collection has an object with the key <code>mapping</code>.
          The value of this key refers to the mapping that provides the IRIs that will serve as object for the predicate-object combination.
          Furthermore, a condition is added, so that only persons and projects are linked when they are actually related, based on the <code>projectID</code>
          of the person and the <code>ID</code> of the project.
          Note that a condition is not required.
          In this example it would result in relationships between every person and every project.
        </p>

          <pre id="example-ref-map" class="example" title="interlinking two mappings">
            mappings:
              person:
                subjects: http://example.com/person/$(ID)
                predicateobjects:
                  - predicates: foaf:worksFor
                    objects:
                    - mapping: person
                      condition:
                        function: equal
                        parameters:
                          - [str1, $(projectID)]
                          - [str2, $(ID)]
              project:
                subjects: http://example.com/project/$(ID)
          </pre>
      </section>
    </section>

    <section>
      <h2>Functions</h2>

      Functions are be added to subjects, predicates, and objects.

      <pre id="example-fn" class="example" title="mapping with function on firstname">
        mappings:
          person:
            predicateobjects:
             - predicates: foaf:firstName
               objects:
                - function: ex:toLowerCase
                  parameters:
                   - parameter: ex:input
                     value: $(firstname)
      </pre>

      A shortcut version of this example looks as follows.

      <pre id="example-fn-sc" class="example" title="mapping with function on firstname using shortcuts">
        mappings:
          person:
            predicateobjects:
             - predicates: foaf:firstName
               objects:
                - function: ex:toLowerCase
                  parameters:
                   - [ex:input, $(firstname)]
      </pre>
    </section>

    <section>
      <h2>Conditions</h2>

      <p>
        A subject or predicate-object combination is in certain cases only generated when a condition is fulfilled.
        In the following example, the predicate-object is only generated when the <code>firstname</code> is valid.
      </p>

        <pre id="example-cond" class="example" title="mapping with condition on predicate object">
          mappings:
            person:
              predicateobjects:
               - predicates: foaf:firstName
                 objects: $(firstname)
                 condition:
                  function: ex:isValid
                  parameters:
                   - [ex:input, $(firstname)]
        </pre>

        In the following example, the mapping is only executed for every record that has set its <code>ID</code>.

        <pre id="example-cond2" class="example" title="mapping with condition">
          mappings:
            person:
              subjects: http://example.com/{ID}
              condition:
                  function: ex:isSet
                  parameters:
                   - [ex:input, $(ID)]
              predicateobjects:
               - predicates: foaf:firstName
                 objects: $(firstname)
        </pre>
    </section>

    <section>
      <h2>Shortcuts</h2>

      <section>
        <h2>Keys</h2>

          <ul>
            <li>subjects: subject, s</li>
            <li>predicates: predicate, p</li>
            <li>inversepredicates: inversepredicate, i</li>
            <li>objects: object, o</li>
            <li>function: fn, f</li>
            <li>parameters: pms</li>
            <li>parameter: pm</li>
            <li>value: v</li>
          </ul>
      </section>

      <section>
        <h2>Predicates</h2>

          <ul>
            <li>http://www.w3.org/1999/02/22-rdf-syntax-ns#type: a</li>
          </ul>
      </section>
    </section>

    <section>
      <h2>Examples</h2>

      <section>
        <h2>From R2RML to YARRRML</h2>
      </section>

      <section>
        <h2>From RML to YARRRML</h2>
      </section>
    </section>
  </body>
</html>
