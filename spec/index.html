<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>YARRRML</title>
    <script 
     src='https://www.w3.org/Tools/respec/respec-w3c-common' 
     class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        editors: [{
          name: "Ben De Meester",
          url: "https://be.de-meester.org",
        },{
          name: "Pieter Heyvaert",
          url: "https://pieterheyvaert.com",
        }],
        processVersion: 2017,
        edDraftURI: "http://some.github.repo",
        shortName: "dahut"
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This is required.
      </p>
    </section>
    <section id='sotd'>
    </section>
    <section>
      <h2>Introduction</h2>

      <section>
        <h2>Goals</h2>

      </section>

      <section>
        <h2>Relation to existing mapping languages</h2>

      </section>

      <section>
        <h2>Relation to YAML</h2>

        <p>
          YARRRML is a subset of the YAML.
        </p>
      </section>
    </section>

    <section>
      <h2>Terminology</h2>

      <dl>
        <di><dfn>subject</dfn></di>
        <dd>the subject of an RDF triple</dd>

        <di><dfn>predicate</dfn></di>
        <dd>the predicate of an RDF triple</dd>

        <di><dfn>object</dfn></di>
        <dd>the object of an RDF triple</dd>

        <di><dfn>class</dfn></di>
        <dd>the type of an entity</dd>

        <di><dfn>datatype</dfn></di>
        <dd>the type of a literal value</dd>

        <di><dfn>reference</dfn></di>
        <dd></dd>

        <di><dfn>function</dfn></di>
        <dd>a programmatic function that takes 0 or more input parameters and returns a single result</dd>
      </dl>
    </section>

    <section>
      <h2>Profiles</h2>

      <p>
        This specification includes the following main profiles for tools that process YARRRML documents:

        <ul>
          <li>R2RML: applies the semantics specified by R2RML; and</li>
          <li>RML: applies the semantics specified by RML.</li>
        </ul>

        These profiles can be extended with additional profiles, which cannot be used on their own:

        <ul>
          <li>FnO: applies the semantics specified by FnO;</li>
          <li>DCAT: applies the semantics specified by DCAT;</li>
          <li>D2RQ: applies the semantics specified by D2RQ;</li>
          <li>SD: applies the semantics specified by SD; and</li>
          <li>CSVW: applies the semantics specified by CSVW.</li>
        </ul>
      </p>
    </section>

    <section>
      <h2>Base IRI</h2>

      <p>
        A base IRI can be defined.
        This IRI will be used for the creation of the IRIs of the term maps and sources of the [R2]RML rules.
      </p>
      <p>
        A base IRI can be added by adding key <code>base</code> with as value the IRI itself to the root of the document.
        In the following example the base IRI is set to <code>http://mybaseiri.com#</code>.

        <pre id="example-base-iri" class="nohighlight example" title="base IRI">
          base: http://mybaseiri.com#
        </pre>
      </p>
    </section>

    <section>
      <h2>Prefixes and namespaces</h2>

      <p>
        A set of prefixes and namespaces are predefined by default in every YARRRML document.
        There are the same as the predefined prefixes for <a href="https://www.w3.org/2011/rdfa-context/rdfa-1.1">RDFa</a>.
      </p>

      <p>
        Custom prefixes can be added by adding the collection <code>prefixes</code> to the root of the document.
        Each combination of a prefix and namespace is added to this collection as a key-value pair.

        In the following example two prefixes are defined: <code>ex</code> and <code>test</code>.

        <pre id="example-custom-prefixes" class="nohighlight example" title="custom prefixes">
          prefixes:
            ex: http://www.example.com
            test: http://www.test.com
        </pre>
      </p>
    </section>

    <section>
      <h2>Template</h2>

      <p>
        A template contains 0 or more constant strings and 0 or more references to data in a data.
        References are prefixed with <code>$(</code> and suffixed with <code>)</code>.
        For example, <code>foo</code> is a template with one constant string.
        <code>$(id)</code> is a template with one reference to <code>id</code>.
        <code>foo-$(id)</code> is a template with one constant string <code>foo-</code> and one reference to <code>id</code>.
      </p>
    </section>

    <section>
      <h2>Data sources</h2>

      <p>
        The data sources are can be defined in the <code>sources</code> collection in the root of the document.
        Each source is added to this collection via a key-value pair.
        The key has to be unique for every source.
        The value is a collection with three keys
        <code>access</code> (required), <code>referenceFormulation</code> (required), and <code>iterator</code> (conditionally required).
      </p>

        <section>
          <h2>Keys</h2>
          <dl>
            <di><dfn>access</dfn></di>
            <dd>the local or remote location of the data source</dd>

            <di><dfn>driver (required profiles: RML, D2RQ)</dfn></di>
            <dd>the local or remote location of the data source</dd>

            <di><dfn>referenceFormulation (required profiles: RML)</dfn></di>
            <dd>the reference formulation used on to access data source</dd>

            <di><dfn>iterator (required profiles: RML)</dfn></di>
            <dd>the path to the different records over which to iterate</dd>

            <di><dfn>delimiter (required profiles: RML, CSVW)</dfn></di>
            <dd>the delimiter to separate fields in a record</dd>

            <di><dfn>encoding (required profiles: RML, CSVW)</dfn></di>
            <dd>the encoding used for the data</dd>

            <di><dfn>query</dfn></di>
            <dd>the query to execute on the data source to select only a part of the data</dd>

            <di><dfn>queryFormulation</dfn></di>
            <dd>the query formulation used on to query the data source</dd>

            <di><dfn>credentials (required profiles: RML, D2RQ)</dfn></di>
            <dd>the credentials required to access the data source</dd>

            <di><dfn>username (required profiles: RML, D2RQ)</dfn></di>
            <dd>the username required to access the data source</dd>

            <di><dfn>password (required profiles: RML, D2RQ)</dfn></di>
            <dd>the password required to access the data source</dd>
          </dl>
        </section>

        <section>
          <h2>Reference formulations</h2>
          The following reference formulations are supported for these data formats.

          <dl>
            <di><dfn>CSV (required profiles: RML)</dfn></di>
            <dd>
              The reference formulation <code>csv</code> is used for data sources in the CSV format.
              No iterator is required.
              Every row of a CSV data source is considered as a record.
            </dd>

            <di><dfn>JSON (required profiles: RML)</dfn></di>
            <dd>
              The reference formulation <code>jsonpath</code> is used for data sources that can be access via JSONPath expressions.
              An iterator is required.
            </dd>

            <di><dfn>XML (required profiles: RML)</dfn></di>
            <dd>
              The reference formulation <code>xpath</code> is used for data sources that can be access via XPath expressions.
              An iterator is required.
              The reference formulation <code>xquery</code> is used for data sources that can be access via XQuery queries.
              No iterator is required.
              Every row of the result of the query is considered as a record.
            </dd>
          </dl>
        </section>

      <section>
        <h2>Query formulations</h2>
        The following query formulation are supported for these query languages.

        <dl>
          <di><dfn>SQL</dfn></di>
          <dd>
            The following query formulations can be used for data sources that can be queried via a SQL query:

            <ul>
              <li>sql2008</li>
              <li>oracle</li>
              <li>mysql</li>
              <li>mssql</li>
              <li>hsql</li>
              <li>postgresql</li>
              <li>db2</li>
              <li>informix</li>
              <li>ingres</li>
              <li>progress</li>
              <li>sybasease</li>
              <li>sybasesqlanywhere</li>
              <li>virtuoso</li>
              <li>firebird</li>
            </ul>

            This list is based on version IRIs identified by <a href="https://www.w3.org/2001/sw/wiki/RDB2RDF/SQL_Version_IRIs">RDB2RDF</a>.
          </dd>

          <di><dfn>SPARQL (required profiles: RML, SD)</dfn></di>
          <dd>
            The query formulation <code>sparql11</code> is used for data sources that can be queried via a SPARQL 1.1 query.
          </dd>
        </dl>
      </section>

        <section>
          <h2>Examples</h2>
          <p>
            In the following example a single data source is defined <code>person-source</code>.

            <pre id="example-ds1" class="example" title="one data source">
              sources:
                person-source:
                  access: data/person.json
                  referenceFormulation: jsonpath
                  iterator: $
            </pre>

            A shortcut version of this example looks as follows.

            <pre id="example-ds1-sc" class="example" title="one data source using shortcuts">
              sources:
                person-source: [data/person.json~jsonpath, $]
            </pre>

            The collection is replaced with an array where
            the first element contains the value for <code>access</code> appended with the <code>~</code> and the value for <code>referenceFormulation</code>, and
            the second element contains the iterator.

          </p>

          <p>
          The following mapping access a SQL database and select the required data via a query.

          <pre id="example-db" class="example" title="mapping with database as source">
            mapping:
              person:
                sources:
                  access: jdbc:mysql://localhost/example
                  driver: com.mysql.jdbc.Driver
                  credentials:
                    username: root
                    password: root
                  queryFormulation: sql2008
                  query: |
                    SELECT DEPTNO, DNAME, LOC,
                    (SELECT COUNT(*) FROM EMP WHERE EMP.DEPTNO=DEPT.DEPTNO) AS STAFF
                    FROM DEPT;
                  referenceFormulation: csv
          </pre>
          </p>
        </section>
    </section>

    <section>
      <h2>Mappings</h2>

        <p>
          The <code>mappings</code> collection contains all the mappings of the document.
          Each mapping is added to this collection via key-value pair.
          The key is unique for each mapping.
          The value is collection containing rules to generate the subjects, predicates, and objects.

          In the following example two mappings are defined: <code>person</code> and <code>project</code>.

          <pre id="example-mappings" class="example" title="two mappings">
            mappings:
              person: ...
                project: ...
          </pre>
      </p>

      <section>
        <h2>Data sources</h2>

        <p>
          Besides defining data sources at the root of the document,
          data sources can also be defined inside a mapping via the collection <code>sources</code>.
          However, no unique key is specified for a source, and, thus, it cannot be referred to from other mappings.
          The key-value to add to a source are the same when defining sources at the root of the document.

          In the following example the mapping <code>person</code> has one source.

          <pre id="example-ds" class="example" title="mapping with one data source">
            mapping:
              person:
                sources:
                  access: data/person.json
                  referenceFormulation: jsonpath
                  iterator: $
          </pre>

          A shortcut version of this example looks as follows.

          <pre id="example-ds-sc" class="example" title="mapping with one data source using shortcuts">
            mapping:
              person:
                sources: [data/person.json~jsonpath, $]
          </pre>

          In case a mapping needs to be applied to multiple data sources, multiple sources can be added to the <code>scources</code> collection.
          In the following example the <code>person</code> mapping has two data sources.

          <pre id="example-ds2" class="nohighlight example" title="mapping with two data sources">
            mapping:
              person:
                sources:
                  - access: data/person.json
                    referenceFormulation: jsonpath
                    iterator: $
                  - access: data/person2.json
                    referenceFormulation: jsonpath
                    iterator: "$.persons[*]"
          </pre>

          A shortcut version of this example looks as follows.

          <pre id="example-ds2-sc" class="nohighlight example" title="mapping with two data sources using shortcuts">
            mapping:
              person:
                sources:
                  - [data/person.json~jsonpath, $]
                  - [data/person2.json~jsonpath, "$.persons[*]"]
          </pre>

          If you describe a data source outside of the mappings, you can include via their unique key.

          <pre id="example-ds3" class="nohighlight example" title="mapping with one data sources">
            sources:
              person-source:
                access: data/person.json
                referenceFormulation: jsonpath
                iterator: $

            mapping:
              person:
                sources: person-source
          </pre>

          Multiple sources can be used by using an array of source keys as value for the key <code>sources</code>.

          <pre id="example-ds4" class="example" title="mapping with two data sources">
            sources:
              person-source:
                access: data/person.json
                referenceFormulation: jsonpath
                iterator: $
              person-source2:
                access: data/person2.json
                referenceFormulation: jsonpath
                iterator: "$.person[*]"

            mapping:
              person:
                sources:
                  - [person-source, person-source2]
          </pre>

          A combination of both sources defined outside and inside a mapping is possible.

          <pre id="example-ds5" class="example" title="mapping with two data sources">
            sources:
              person-source:
                access: data/person.json
                referenceFormulation: jsonpath
                iterator: $

            mapping:
              person:
                sources:
                 - person-source
                 - access: data/person2.json
                   referenceFormulation: jsonpath
                   iterator: "$.persons[*]"
          </pre>
        </p>
      </section>

      <section>
        <h2>Subjects</h2>

        <p>
          For every triple is required to define whether a IRI or blank node needs to used.
          This information is added to a mapping via the collection <code>subjects</code>.
          In the case of an IRI , this collection contains 0 or more templates that specify the IRI.
          In the case of a blank node, this collection is set to <code>null</code> or is not specified at all.

          In the following example the mapping <code>person</code> generate IRI for the subjects based on the template <code>http://wwww.example.com/person/$(id)</code>.

          <pre id="example-subject" class="nohighlight example" title="mapping with one subject">
            mappings:
              person:
                subjects: http://wwww.example.com/person/$(id)
          </pre>

          It is also possible to specify multiple subjects.
          In this case an array of templates is used.
          In the following example the mapping <code>person</code> generate subjects based on the templates <code>http://wwww.example.com/person/$(id)</code>
          and <code>http://www.test.com/$(firstname)</code>.

          <pre id="example-subject2" class="example" title="mapping with two subjects">
              mappings:
                person:
                  subjects: [http://wwww.example.com/person/$(id), http://www.test.com/$(firstname)]
          </pre>

          It is possible to apply functions on subjects.
        </p>
      </section>

      <section>
        <h2>Predicates and objects</h2>

        **ADD MORE**

        In the following example the mapping <code>person</code> generates combinations of predicates and objects,
        where the predicate is <code>foaf:firstName</code> and the object is the <code>firstname</code> of each person.

        <pre id="example-po" class="example" title="mapping with one predicate and object">
          mappings:
            person:
              predicateobjects:
                - predicates: foaf:firstName
                  objects: $(firstname)
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-po-sc" class="example" title="mapping with one predicate and object using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [foaf:firstName, $(firstname)]
        </pre>

        It is possible to speficiy multiple predicates and objects.
        In this case an array of templates is used.

        <pre id="example-po2" class="example" title="mapping with two predicates and objects">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects: [$(firstname), $(lastname)]
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-po2-sc" class="example" title="mapping with two predicates and objects using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [[foaf:name, rdfs:label], [$(firstname), $(lastname)]]
        </pre>

        <pre id="example-po3" class="example" title="mapping with object that generates an IRI">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects:
                    value: $(colleague)
                    type: iri
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-po3-sc" class="example" title="mapping with object that generates an IRI using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [[foaf:name, rdfs:label], $(colleague)~iri]
        </pre>

        The inverse predicate can also be added.
        This is only valid when the object is an IRI or a blank node.

        <pre id="example-po-inverse" class="example" title="mapping with one inverse predicate">
          mappings:
            work:
              predicateobjects:
                - predicates: ex:createdBy
                  inversepredicates: ex:created
                  objects: $(foafprofile)
                  type: iri
        </pre>
      </section>

      <section>
        <h2>Datatypes</h2>

        <pre id="example-datatype" class="example" title="mapping with one datatype">
          mappings:
            person:
              predicateobjects:
                - predicates: foaf:firstName
                  objects:
                    value: $(firstname)
                    datatype: xsd:string
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-datatype-sc" class="example" title="mapping with one datatype using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [foaf:firstName, $(firstname), xsd:string]
        </pre>

        <pre id="example-datatype2" class="example" title="mapping with two datatypes">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects:
                    - value: $(firstname)
                      datatype: ex:string
                    - value: $(lastname)
                      datatype: ex:anotherString
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-datatype2-sc" class="example" title="mapping with two datatypes using shortcuts">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects: [[$(firstname), ex:string], [$(lastname), ex:anotherString]]
        </pre>
      </section>

      <section>
        <h2>Languages</h2>

        <pre id="example-lang" class="example" title="mapping with one language">
          mappings:
            person:
              predicateobjects:
                - predicates: foaf:firstName
                  objects:
                    value: $(firstname)
                    language: en
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-lang-sc" class="example" title="mapping with one language using shortcuts">
          mappings:
            person:
              predicateobjects:
                - [foaf:firstName, $(firstname), en~lang]
        </pre>

        <pre id="example-lang2" class="example" title="mapping with two languages">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects:
                    - value: $(firstname)
                      language: en
                    - value: $(lastname)
                      language: nl
        </pre>

        A shortcut version of this example looks as follows.

        <pre id="example-lang2-sc" class="example" title="mapping with two languages using shortcuts">
          mappings:
            person:
              predicateobjects:
                - predicates: [foaf:name, rdfs:label]
                  objects: [[$(firstname), en~lang], [$(lastname), nl~lang]]
        </pre>
      </section>

      <section>
        <h2>Referring to other mappings</h2>

        <p>
          In certain use cases triples need to be generated between the records of two mappings.
          For example, in the following example we have two mappings: persons and projects.
          In the existing data there is for every person a field <code>projectID</code> referring to the project
          on which the person is working.
          Therefore, we want to generate triples between every person and his/her project.
          The <code>objects</code> collection has an object with the key <code>mapping</code>.
          The value of this key refers to the mapping that provides the IRIs that will serve as object for the predicate-object combination.
          Furthermore, a condition is added, so that only persons and projects are linked when they are actually related, based on the <code>projectID</code>
          of the person and the <code>ID</code> of the project.
          Note that a condition is not required.
          In this example it would result in relationships between every person and every project.

          <pre id="example-ref-map" class="example" title="interlinking two mappings">
            mappings:
              person:
                subjects: http://example.com/person/$(ID)
                predicateobjects:
                  - predicates: foaf:worksFor
                  - objects:
                    - mapping: person
                      condition:
                        function: equal
                        parameters:
                          - [ex:input1, $(projectID)]
                          - [ex:input2, $(ID)]
              project:
                subjects: http://example.com/project/$(ID)
          </pre>
        </p>
      </section>
    </section>

    <section>
      <h2>Functions</h2>

      Functions are be added to subjects, predicates, and objects.

      <pre id="example-fn" class="example" title="mapping with function on firstname">
        mappings:
          person:
            predicateobjects:
             - predicates: foaf:firstName
               objects:
                - function: ex:toLowerCase
                  parameters:
                   - parameter: ex:input
                     value: $(firstname)
      </pre>

      A shortcut version of this example looks as follows.

      <pre id="example-fn-sc" class="example" title="mapping with function on firstname using shortcuts">
        mappings:
          person:
            predicateobjects:
             - predicates: foaf:firstName
               objects:
                - function: ex:toLowerCase
                  parameters:
                   - [ex:input, $(firstname)]
      </pre>
    </section>

    <section>
      <h2>Conditions</h2>

      <p>
        A subject or predicate-object combination is in certain cases only generated when a condition is fulfilled.
        In the following example, the predicate-object is only generated when the <code>firstname</code> is valid.

        <pre id="example-cond" class="example" title="mapping with condition on predicate object">
          mappings:
            person:
              predicateobjects:
               - predicates: foaf:firstName
                 objects: $(firstname)
                 condition:
                  function: ex:isValid
                  parameters:
                   - [ex:input, $(firstname)]
        </pre>

        In the following example, the mapping is only executed for every record that has set its <code>ID</code>.

        <pre id="example-cond2" class="example" title="mapping with condition">
          mappings:
            person:
              subjects: http://example.com/{ID}
              condition:
                  function: ex:isSet
                  parameters:
                   - [ex:input, $(ID)]
              predicateobjects:
               - predicates: foaf:firstName
                 objects: $(firstname)
        </pre>
      </p>
    </section>

    <section>
      <h2>Shortcuts</h2>

      <section>
        <h2>Keys</h2>

        <p>
          <ul>
            <li>subjects: subject, s</li>
            <li>predicates: predicate, p</li>
            <li>inversepredicates: inversepredicate, i</li>
            <li>objects: object, o</li>
            <li>function: fn, f</li>
            <li>parameters: pms</li>
            <li>parameter: pm</li>
            <li>value: v</li>
          </ul>
        </p>
      </section>

      <section>
        <h2>Predicates</h2>

        <p>
          <ul>
            <li>http://www.w3.org/1999/02/22-rdf-syntax-ns#type: a</li>
          </ul>
        </p>
      </section>
    </section>

    <section>
      <h2>Examples</h2>

      <section>
        <h2>From R2RML to YARRRML</h2>
      </section>

      <section>
        <h2>From RML to YARRRML</h2>
      </section>
    </section>
  </body>
</html>
